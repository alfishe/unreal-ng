#include "soundchip_ay8910.h"

#include "common/stringhelper.h"
#include <cstring>

/// region <Nested classes>

/// region <ToneGenerator>

SoundChip_AY8910::ToneGenerator::ToneGenerator()
{
    reset();
}

void SoundChip_AY8910::ToneGenerator::reset()
{
    _period = 0x0001;
    _counter = 0x0000'0000;
    _volume = 0;

    _envelopeEnabled = false;
    _toneEnabled = false;
    _noiseEnabled = false;

    _out = false;
}

/// The frequency of each square wave generated by the three Tone Generators
/// (one each for Channels A, B, and C) is obtained in the PSG by first
/// counting down the input clock by 16, then by further counting down the
/// result by the programmed 12-bit Tone Period value. Each 12-bit value
/// is obtained in the PSG by combining the contents of relative Coarse and
/// Fine Tune registers. (R1 + R0 for Channel A, R3 + R2 for Channel B,
/// R5 + R4 for Channel C)
void SoundChip_AY8910::ToneGenerator::setPeriod(uint8_t fine, uint8_t coarse)
{
    // 4 lowest bits from coarse + 8 bits from fine forms 12-bit Tone Period of Tone Generator
    uint16_t value = coarse & 0b0000'1111;
    value = value << 8 | fine;

    // Period cannot be zero, so set it to 1 if detected
    _period = (value == 0) | value;
}

void SoundChip_AY8910::ToneGenerator::setVolume(uint8_t volume)
{
    // Only 4 bits used
    _volume = volume & 0b0000'1111;
}

void SoundChip_AY8910::ToneGenerator::setEnvelopeEnabled(bool value)
{
    _envelopeEnabled = value;
}

void SoundChip_AY8910::ToneGenerator::setToneEnabled(bool value)
{
    _toneEnabled = value;
}

void SoundChip_AY8910::ToneGenerator::setNoiseEnabled(bool value)
{
    _noiseEnabled = value;
}

void SoundChip_AY8910::ToneGenerator::setPanLeft(double value)
{
    _panLeft = value;
}

void SoundChip_AY8910::ToneGenerator::setPanRight(double value)
{
    _panRight = value;
}

bool SoundChip_AY8910::ToneGenerator::updateState()
{
    // 0 period is not played
    if (_period > 0)
    {
        _counter++;

        if (_counter >= _period)
        {
            _counter = 0;
            _out = !_out;
        }
    }

    return _out;
}

/// endregion </ToneGenerator>

/// region <NoiseGenerator>

SoundChip_AY8910::NoiseGenerator::NoiseGenerator()
{
    reset();
}

void SoundChip_AY8910::NoiseGenerator::reset()
{
    _period = 0x01;
    _counter = 0x00;
    //_registerLSFR = 0xFFFF'FFFF;
    _registerLSFR = 1;
}

void SoundChip_AY8910::NoiseGenerator::setPeriod(uint8_t period)
{
    // Only 5 bits used
    period &= 0b0001'1111;

    // Period cannot be zero, so set it to 1 if detected
    _period = (period == 0) | period;
}

bool SoundChip_AY8910::NoiseGenerator::updateState()
{
    _counter++;

    if (_counter >= (_period << 1))
    {
        _counter = 0;

        _out = shiftLSFR();
    }

    return _out;
}

/// Returns LSFR-generated random numbers for noise generator
/// @return Output from LSFR bit 0
///
/// <b>Information:</b>
/// The Random Number Generator of the 8910 is a 17-bit shift register.
/// The input to the shift register is bit0 XOR bit3
/// Bit0 is the output
/// 17 stage LSFR with 1 tap (3)
///
/// See: https://en.wikipedia.org/wiki/Linear-feedback_shift_register
/// See: https://github.com/floooh/chips/blob/master/chips/ay38910.h
/// See: https://github.com/mamedev/mame/blob/master/src/devices/sound/ay8910.cpp
bool SoundChip_AY8910::NoiseGenerator::shiftLSFR()
{
    uint32_t tapBit = (_registerLSFR & 1) ^ ((_registerLSFR >> 3) & 1); // Calculate tap (XOR of bits 0 and 3)
    _registerLSFR = (_registerLSFR >> 1) | (tapBit << 16); // Right-shift the LFSR and insert tap value at the most significant bit

    // Return output bit [0]
    return _registerLSFR & 1;
}
/// endregion </NoiseGenerator>

/// region <EnvelopeGenerator>

/// 4 lowest bits of R13 (Envelope shape) register determine envelope shape
/// at the Envelope Generator Output
/// See more in AY-8910 datasheet (page 5-22): http://map.grauw.nl/resources/sound/generalinstrument_ay-3-8910.pdf
SoundChip_AY8910::EnvelopeGenerator::EnvelopeHandler SoundChip_AY8910::EnvelopeGenerator::_handlers[ENVELOPE_SHAPE_COUNT][ENVELOPE_SEGMENTS] =
{
    { &SoundChip_AY8910::EnvelopeGenerator::slideDown, &SoundChip_AY8910::EnvelopeGenerator::holdBottom },       // 00 - 0b0000 - \___ ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideDown, &SoundChip_AY8910::EnvelopeGenerator::holdBottom },       // 01 - 0b0001 - \___ ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideDown, &SoundChip_AY8910::EnvelopeGenerator::holdBottom },       // 02 - 0b0010 - \___ ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideDown, &SoundChip_AY8910::EnvelopeGenerator::holdBottom },       // 03 - 0b0011 - \___ ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideUp,   &SoundChip_AY8910::EnvelopeGenerator::holdBottom },       // 04 - 0b0100 - /___ ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideUp,   &SoundChip_AY8910::EnvelopeGenerator::holdBottom },       // 05 - 0b0101 - /___ ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideUp,   &SoundChip_AY8910::EnvelopeGenerator::holdBottom },       // 06 - 0b0110 - /___ ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideUp,   &SoundChip_AY8910::EnvelopeGenerator::holdBottom },       // 07 - 0b0111 - /___ ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideDown, &SoundChip_AY8910::EnvelopeGenerator::slideDown  },       // 08 - 0b1000 - \\\\ ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideDown, &SoundChip_AY8910::EnvelopeGenerator::holdBottom },       // 09 - 0b1001 - \___ ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideDown, &SoundChip_AY8910::EnvelopeGenerator::slideUp    },       // 0A - 0b1010 - \/\/ ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideDown, &SoundChip_AY8910::EnvelopeGenerator::holdTop    },       // 0B - 0b1011 - \--- ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideUp,   &SoundChip_AY8910::EnvelopeGenerator::slideUp    },       // 0C - 0b1100 - //// ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideUp,   &SoundChip_AY8910::EnvelopeGenerator::holdTop    },       // 0D - 0b1101 - /--- ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideUp,   &SoundChip_AY8910::EnvelopeGenerator::slideDown  },       // 0E - 0b1110 - /\/\ ;
    { &SoundChip_AY8910::EnvelopeGenerator::slideUp,   &SoundChip_AY8910::EnvelopeGenerator::holdBottom }        // 0F - 0b1111 - /___ ;
};

SoundChip_AY8910::EnvelopeGenerator::EnvelopeGenerator()
{
    reset();
}

void SoundChip_AY8910::EnvelopeGenerator::reset()
{
    _period = 0x0000'0001;
    _shape = 0;

    _counter = 0;
    _segment = 0;
    _out = 0;
}

/// Set envelope generator period (Registers R13 - fine and R14 - coarse bits)
/// @param fine 8 lowest bits
/// @param coarse 8 highest bits
void SoundChip_AY8910::EnvelopeGenerator::setPeriod(uint8_t fine, uint8_t coarse)
{
    uint32_t value = (coarse << 8) | fine;

    // Period cannot be zero, so set it to 1 if detected
    _period = (value == 0) | value;
}

/// Sets current envelope shape [0:15] from register R15
/// @param shape 4 lowest bits define envelope shape
void SoundChip_AY8910::EnvelopeGenerator::setShape(uint8_t shape)
{
    _shape = shape & 0b0000'1111;
    _counter = 0;
    _segment = 0;

    resetSegment();
}

uint8_t SoundChip_AY8910::EnvelopeGenerator::updateState()
{
    if (_counter >= _period)
    {
        _counter = 0;

        // Call envelope handler according handler matrix
        _handlers[_shape][_segment](this);
    }

    _counter++;

    return _out;
}

void SoundChip_AY8910::EnvelopeGenerator::resetSegment()
{
    EnvelopeHandler handler = _handlers[_shape][_segment];
    if (handler == &slideDown || handler == &holdTop)
    {
        _out = 0x1F;    // Set max value
    }
    else
    {
        _out = 0x00;
    }
}

/// region <Envelope handlers>
void SoundChip_AY8910::EnvelopeGenerator::slideUp(EnvelopeGenerator* obj)
{
    obj->_out += 1;

    if (obj->_out > 31)
    {
        obj->_segment ^= 1;
        obj->resetSegment();
    }
}

void SoundChip_AY8910::EnvelopeGenerator::slideDown(EnvelopeGenerator* obj)
{
    obj->_out -= 1;

    if (obj->_out < 0)
    {
        obj->_segment ^= 1;
        obj->resetSegment();
    }
}

void SoundChip_AY8910::EnvelopeGenerator::holdTop([[maybe_unused]] EnvelopeGenerator* obj)
{
    // Do nothing
}

void SoundChip_AY8910::EnvelopeGenerator::holdBottom([[maybe_unused]] EnvelopeGenerator* obj)
{
    // Do nothing
}

/// endregion </Envelope handlers>

/// endregion </EnvelopeGenerator>

/// endregion </Nested classes>

const char* SoundChip_AY8910::AYRegisterNames[16]
{
    " R0 - Channel A - fine tune",      // R0
    " R1 - Channel A - coarse tune",    // R1
    " R2 - Channel B - fine tune",      // R2
    " R3 - Channel B - coarse tune",    // R3
    " R4 - Channel C - fine tune",      // R4
    " R5 - Channel C - coarse tune",    // R5
    " R6 - Noise period",               // R6
    " R7 - Mixer Control Enable",       // R7
    "R10 - Channel A - Amplitude",      // R8
    "R11 - Channel B - Amplitude",      // R9
    "R12 - Channel C - Amplitude",      // R10
    "R13 - Envelope period - fine",     // R11
    "R14 - Envelope period - coarse",   // R12
    "R15 - Envelope shape",             // R13
    "R16 - I/O Port A data store",      // R14
    "R17 - I/O Port B data store"       // R15
};

/// region <Constructors / Destructors>

SoundChip_AY8910::SoundChip_AY8910(EmulatorContext* context) : PortDecoder(context)
{
    reset();
}

/// endregion </Constructors / Destructors>

/// region <Methods>

void SoundChip_AY8910::reset()
{
    // Reset whole registers array
    memset(&_registers, 0x00, sizeof(_registers));
    _currentRegister = 0;
    _registers[AY_MIXER_CONTROL] = 0xFF;  // Mute all generator outputs

    // Reset generators
    _toneGenerators[AY_CHANNEL_A].reset();
    _toneGenerators[AY_CHANNEL_B].reset();
    _toneGenerators[AY_CHANNEL_C].reset();
    _noiseGenerator.reset();
    _envelopeGenerator.reset();

    // Reset panning coefficients
    /// region <ABC>
    if (true)
    {
        _toneGenerators[AY_CHANNEL_A].setPanLeft(0.9);
        _toneGenerators[AY_CHANNEL_A].setPanRight(0.1);
        _toneGenerators[AY_CHANNEL_B].setPanLeft(0.5);
        _toneGenerators[AY_CHANNEL_B].setPanRight(0.5);
        _toneGenerators[AY_CHANNEL_C].setPanLeft(0.1);
        _toneGenerators[AY_CHANNEL_C].setPanRight(0.9);
    }
    else
    {
        _toneGenerators[AY_CHANNEL_A].setPanLeft(0.65);
        _toneGenerators[AY_CHANNEL_A].setPanRight(0.35);
        _toneGenerators[AY_CHANNEL_B].setPanLeft(0.5);
        _toneGenerators[AY_CHANNEL_B].setPanRight(0.5);
        _toneGenerators[AY_CHANNEL_C].setPanLeft(0.35);
        _toneGenerators[AY_CHANNEL_C].setPanRight(0.65);
    }
    /// endregion </ABC>
    /// region <ACB>
    if (false)
    {
        _toneGenerators[AY_CHANNEL_A].setPanLeft(0.9);
        _toneGenerators[AY_CHANNEL_A].setPanRight(0.1);
        _toneGenerators[AY_CHANNEL_B].setPanLeft(0.1);
        _toneGenerators[AY_CHANNEL_B].setPanRight(0.9);
        _toneGenerators[AY_CHANNEL_C].setPanLeft(0.5);
        _toneGenerators[AY_CHANNEL_C].setPanRight(0.5);
    }
    /// endregion </ACB>
    /// region <Debug A-left>
    if (false)
    {
        _toneGenerators[AY_CHANNEL_A].setPanLeft(1.0);
        _toneGenerators[AY_CHANNEL_A].setPanRight(0.0);
        _toneGenerators[AY_CHANNEL_B].setPanLeft(0.0);
        _toneGenerators[AY_CHANNEL_B].setPanRight(1.0);
        _toneGenerators[AY_CHANNEL_C].setPanLeft(0.0);
        _toneGenerators[AY_CHANNEL_C].setPanRight(1.0);
    }
    /// endregion </Debug A-left>

    // Reset internal tick counter
    _tick = 0;
}

/// Emulate single AY chip clock cycle
/// All generator counters updated, output mixer value
void SoundChip_AY8910::updateState(bool bypassPrescaler)
{
    _tick++;

    // Update state for all generators
    if (bypassPrescaler || _tick % 8 == 0)    // Turn on 16 pre-scaler for all generators
    {
        _noiseGenerator.updateState();
        _envelopeGenerator.updateState();

        _toneGenerators[AY_CHANNEL_A].updateState();
        _toneGenerators[AY_CHANNEL_B].updateState();
        _toneGenerators[AY_CHANNEL_C].updateState();

        // Mix outputs into samples
        updateMixer();
    }
}

void SoundChip_AY8910::updateMixer()
{
    // Zero-down all output samples
    _mixedLeft = 0.0;
    _mixedRight = 0.0;

    for (size_t i = 0; i < TONE_CHANNELS; i++)
    {
        ToneGenerator& toneGenerator = _toneGenerators[i];
        uint8_t channelOut;

        // Apply mixer flags and mix tone and noise accordingly
        // Formula: (ToneOn | ToneDisable) & (NoiseOn | NoiseDisable)
        // Note: disabling both noise and tone does not turn off a channel.
        // Turning a channel off can only be accomplished by writing all zeroes
        // Into corresponding bits of R10, R11 and R12 for corresponding channel
        channelOut = (toneGenerator.out() || !toneGenerator.toneEnabled()) && (_noiseGenerator.out() || !toneGenerator.noiseEnabled());

        // Apply volume (set via register or controlled by envelope generator)
        uint8_t volume = toneGenerator.envelopeEnabled() ? _envelopeGenerator.out() : toneGenerator.volume() * 2 + 1;
        channelOut *= volume;
        channelOut &= 0x1F; // Ensure that amplitude not exceed 5 bit value

        _left[i] = _volumeDACTablePtr[channelOut];
        _right[i] = _volumeDACTablePtr[channelOut];

        _mixedLeft += _left[i] * toneGenerator.panLeft();
        _mixedRight += _right[i] * toneGenerator.panRight();
    }

    _mixedRight /= 3.0;
    _mixedLeft /= 3.0;

    // Filter out DC offset
    if (true)
    {
        _mixedLeft = _filterDCLeft.filter(_mixedLeft);
        _mixedRight = _filterDCRight.filter(_mixedRight);
    }
}

void SoundChip_AY8910::setMixer(uint8_t mixerValue)
{
    bool isChannelAToneEnabled = (mixerValue & 0b0000'0001) == 0;
    bool isChannelBToneEnabled = (mixerValue & 0b0000'0010) == 0;
    bool isChannelCToneEnabled = (mixerValue & 0b0000'0100) == 0;

    bool isChannelANoiseEnabled = (mixerValue & 0b0000'1000) == 0;
    bool isChannelBNoiseEnabled = (mixerValue & 0b0001'0000) == 0;
    bool isChannelCNoiseEnabled = (mixerValue & 0b0010'0000) == 0;

    _toneGenerators[AY_CHANNEL_A].setToneEnabled(isChannelAToneEnabled);
    _toneGenerators[AY_CHANNEL_B].setToneEnabled(isChannelBToneEnabled);
    _toneGenerators[AY_CHANNEL_C].setToneEnabled(isChannelCToneEnabled);

    _toneGenerators[AY_CHANNEL_A].setNoiseEnabled(isChannelANoiseEnabled);
    _toneGenerators[AY_CHANNEL_B].setNoiseEnabled(isChannelBNoiseEnabled);
    _toneGenerators[AY_CHANNEL_C].setNoiseEnabled(isChannelCNoiseEnabled);
}

void SoundChip_AY8910::setVolume(uint8_t volume, uint8_t channel)
{
    _toneGenerators[channel].setVolume(volume);
}

void SoundChip_AY8910::setRegister(uint8_t regAddr)
{
    // Only valid register can be selected
    if (regAddr <= 0x0F)
        _currentRegister = regAddr;
}

uint8_t SoundChip_AY8910::readCurrentRegister()
{
    uint8_t result = readRegister(_currentRegister);

    return result;
}

void SoundChip_AY8910::writeCurrentRegister(uint8_t value)
{
    writeRegister(_currentRegister, value);
}

uint8_t SoundChip_AY8910::readRegister(uint8_t regAddr)
{
    uint8_t result = 0xFF;

    // Return value for valid register address, otherwise 0xFF
    if (regAddr <= 0x0F)
    {
        result = _registers[regAddr];
    }

    return result;
}


void SoundChip_AY8910::writeRegister(uint8_t regAddr, uint8_t value)
{
    // Invalid register address provided - ignore it
    if (regAddr > 0x0F)
    {
        return;
    }

    // XOR value with previous state => all non-zeroed bits indicate the change
    //uint8_t changedBits = _registers[regAddr] ^ value;

    // Apply new register value
    _registers[regAddr] = value;

    switch (regAddr)
    {
        // Change period (frequency) for Channel A Tone Generator
        case AY_A_FINE:
        case AY_A_COARSE:
            _toneGenerators[AY_CHANNEL_A].setPeriod(_registers[AY_A_FINE], _registers[AY_A_COARSE]);
            break;
        // Change period (frequency) for Channel B Tone Generator
        case AY_B_FINE:
        case AY_B_COARSE:
            _toneGenerators[AY_CHANNEL_B].setPeriod(_registers[AY_B_FINE], _registers[AY_B_COARSE]);
            break;
        // Change period (frequency) for Channel C Tone Generator
        case AY_C_FINE:
        case AY_C_COARSE:
            _toneGenerators[AY_CHANNEL_C].setPeriod(_registers[AY_C_FINE], _registers[AY_C_COARSE]);
            break;
        // Change period (frequency) for Noise Generator
        case AY_NOISE_PERIOD:
            _noiseGenerator.setPeriod(_registers[AY_NOISE_PERIOD]);
            break;
        case AY_MIXER_CONTROL:
            setMixer(_registers[AY_MIXER_CONTROL]);
            break;
        // Change volume for Channel A
        case AY_A_VOLUME:
        {
            ToneGenerator& generator = _toneGenerators[AY_CHANNEL_A];
            uint8_t volume = _registers[AY_A_VOLUME];
            bool isEnvelopeEnabled = (volume & 0b0001'0000) >> 4;

            generator.setVolume(volume);
            generator.setEnvelopeEnabled(isEnvelopeEnabled);
            break;
        }
        // Change volume for Channel B
        case AY_B_VOLUME:
        {
            ToneGenerator& generator = _toneGenerators[AY_CHANNEL_B];
            uint8_t volume = _registers[AY_B_VOLUME];
            bool isEnvelopeEnabled = (volume & 0b0001'0000) >> 4;

            generator.setVolume(volume);
            generator.setEnvelopeEnabled(isEnvelopeEnabled);
            break;
        }
        // Change volume for Channel C
        case AY_C_VOLUME:
        {
            ToneGenerator& generator = _toneGenerators[AY_CHANNEL_C];
            uint8_t volume = _registers[AY_C_VOLUME];
            bool isEnvelopeEnabled = (volume & 0b0001'0000) >> 4;

            generator.setVolume(volume);
            generator.setEnvelopeEnabled(isEnvelopeEnabled);
            break;
        }
        // Change period (frequency) for Envelope Generator
        case AY_ENVELOPE_PERIOD_FINE:
        case AY_ENVELOPE_PERIOD_COARSE:
            _envelopeGenerator.setPeriod(_registers[AY_ENVELOPE_PERIOD_FINE], _registers[AY_ENVELOPE_PERIOD_COARSE]);
            break;
        // Set one of 16 envelope shapes
        case AY_ENVELOPE_SHAPE:
            _envelopeGenerator.setShape(_registers[AY_ENVELOPE_SHAPE]);
            break;
        default:
            // Do nothing
            break;
    }

    // TODO: Here we can log all register writes to get YM/MYM files
    if (false)
    {
        const char* registerName = SoundChip_AY8910::AYRegisterNames[regAddr];
        std::cout << StringHelper::Format("Register: %-30s Value: 0x%02X", registerName, value) << std::endl;
        if (regAddr == 0x07)
        {
            std::cout << dumpAY8910MixerState() << std::endl;
        }
    }
}

/// endregion </Methods>

/// region <PortDevice interface methods>

uint8_t SoundChip_AY8910::portDeviceInMethod([[maybe_unused]] uint16_t port)
{
    uint8_t result = 0xFF;

    if (_currentRegister < 0x10)
    {
        result = _registers[_currentRegister];
    }

    return result;
}

void SoundChip_AY8910::portDeviceOutMethod(uint16_t port, uint8_t value)
{
    switch (port)
    {
        case PORT_FFFD:
            setRegister(value);
            break;
        case PORT_BFFD:
            writeCurrentRegister(value);
            break;
        default:
            break;
    }
}

/// endregion </PortDevice interface methods>

/// region <Ports interaction>

bool SoundChip_AY8910::attachToPorts(PortDecoder* decoder)
{
    bool result = false;

    if (decoder)
    {
        _portDecoder = decoder;

        [[maybe_unused]] PortDevice* device = this;
        result = decoder->RegisterPortHandler(0xBFFD, this);
        result &= decoder->RegisterPortHandler(0xFFFD, this);

        if (result)
        {
            _chipAttachedToPortDecoder = true;
        }
    }

    return result;
}

void SoundChip_AY8910::detachFromPorts()
{
    if (_portDecoder && _chipAttachedToPortDecoder)
    {
        _portDecoder->UnregisterPortHandler(0xBFFD);
        _portDecoder->UnregisterPortHandler(0xFFFD);

        _chipAttachedToPortDecoder = false;
    }
}

/// endregion </Ports interaction>

/// region <Debug methods>

uint32_t SoundChip_AY8910::getToneGeneratorDivisor(uint8_t fine, uint8_t coarse)
{
    uint32_t result = (coarse & 0b0000'1111) << 8 | fine;

    // Period cannot be infinite so divisor cannot be zero. AY sets minimally acceptable value = 1
    if (result == 0)
        result = 1;

    result *= 16;

    return result;
}

double SoundChip_AY8910::getToneGeneratorFrequency([[maybe_unused]] size_t baseFrequency, uint8_t fine, uint8_t coarse)
{
    uint16_t divisor = (coarse & 0b0000'1111) << 8 | fine;

    // Period cannot be infinite so divisor cannot be zero. AY sets minimally acceptable value = 1
    if (divisor == 0)
        divisor = 1;

    double result = static_cast<double>(AY_BASE_FREQUENCY) / (divisor * 16);

    return result;
}

double SoundChip_AY8910::getNoiseGeneratorFrequency(size_t baseFrequency, uint8_t divisor)
{
    // Only lowest 5 bits contain divisor
    uint8_t normalizedDivisor = divisor & 0b0001'1111;

    // Period cannot be infinite so divisor cannot be zero. AY sets minimally acceptable value = 1
    if (normalizedDivisor == 0)
        normalizedDivisor = 1;

    double result = static_cast<double>(baseFrequency) / (normalizedDivisor * 16);

    return result;
}

std::string SoundChip_AY8910::printFrequency(double frequency)
{
    std::string result = "<Invalid frequency>";

    if (frequency >= 0.0)
    {
        if (frequency < 1000.0)
        {
            result = StringHelper::Format("%.1lfHz", frequency);
        }
        else if  (frequency < 1'000'000.0)
        {
            result = StringHelper::Format("%.2lfkHz", frequency / 1'000.0);
        }
        else
        {
            result = StringHelper::Format("%.3lfMHz", frequency / 1'000'000.0);
        }
    }

    return result;
}

///
/// @see https://f.rdw.se/AY-3-8910-datasheet.pdf Page 17
/// @param targetFrequency
/// @param audioChipClockRate
/// @return
std::string SoundChip_AY8910::printToneDivisorsFromFrequency(double targetFrequency, double audioChipClockRate)
{
    std::string result;

    if (targetFrequency > 20'000 || audioChipClockRate > 2'000'000)
    {
        result = "Invalid parameter. targetFrequency must be >20kHz and audioChipClockRate <= 2MHz";

        return result;
    }

    uint16_t tonePeriod = (uint16_t)(audioChipClockRate / (16.0 * targetFrequency));
    uint8_t coarseTuneValue = tonePeriod / 256;
    uint8_t fineTuneValue = tonePeriod % 256;

    result = StringHelper::Format("For the required: %d Hz frequency\n  Coarse: %s\n  Fine:   %s\n",
                                  (uint32_t)targetFrequency,
                                  StringHelper::FormatBinary(coarseTuneValue).c_str(),
                                  StringHelper::FormatBinary(fineTuneValue).c_str());

    return result;
}

std::string SoundChip_AY8910::dumpAY8910State()
{
    std::stringstream ss;

    ss << std::endl;
    ss << "AY8910 state:" << std::endl;
    ss << StringHelper::Format("  tick: %d", _tick) << std::endl;
    ss << StringHelper::Format("                Left: %lf", _mixedLeft);
    ss << StringHelper::Format("      Right: %lf", _mixedRight) << std::endl;
    ss << StringHelper::Format("  A sample: %.8lf", _left[AY_CHANNEL_A]);
    ss << StringHelper::Format("  B sample: %.8lf", _left[AY_CHANNEL_B]);
    ss << StringHelper::Format("  C sample: %.8lf", _left[AY_CHANNEL_C]) << std::endl;
    ss << StringHelper::Format("  A sample:     0x%04X", (int16_t)(_left[AY_CHANNEL_A] * INT16_MAX));
    ss << StringHelper::Format("  B sample:     0x%04X", (int16_t)(_left[AY_CHANNEL_B] * INT16_MAX));
    ss << StringHelper::Format("  C sample:     0x%04X", (int16_t)(_left[AY_CHANNEL_C] * INT16_MAX)) << std::endl;

    ss << StringHelper::Format("  A volume:       0x%02X", _toneGenerators[AY_CHANNEL_A].volume());
    ss << StringHelper::Format("  B volume:       0x%02X", _toneGenerators[AY_CHANNEL_B].volume());
    ss << StringHelper::Format("  C volume:       0x%02X", _toneGenerators[AY_CHANNEL_C].volume()) << std::endl;

    ss << dumpAY8910MixerState();

    ss << dumpAY8910ToneGeneratorState(AY_CHANNEL_A) << std::endl;
    ss << dumpAY8910ToneGeneratorState(AY_CHANNEL_B) << std::endl;
    ss << dumpAY8910ToneGeneratorState(AY_CHANNEL_C) << std::endl;

    ss << dumpAY8910NoiseGeneratorState() << std::endl;
    ss << dumpAY8910EnvelopeGeneratorState() << std::endl;


    return ss.str();
}

std::string SoundChip_AY8910::dumpAY8910MixerState()
{
    std::stringstream ss;
    uint8_t regValue = _registers[AY_MIXER_CONTROL];

    ss << StringHelper::Format("Mixer value: 0x%02X (%d) %s", regValue, regValue, StringHelper::FormatBinary(regValue).c_str()) << std::endl;
    ss << "  Channel A tone : " << (!(regValue & 0b0000'0001) ? "On " : "Off");
    ss << "  Channel B tone : " << (!(regValue & 0b0000'0010) ? "On " : "Off");
    ss << "  Channel C tone : " << (!(regValue & 0b0000'0100) ? "On " : "Off") << std::endl;
    ss << "  Channel A noise: " << (!(regValue & 0b0000'1000) ? "On " : "Off");
    ss << "  Channel B noise: " << (!(regValue & 0b0001'0000) ? "On " : "Off");
    ss << "  Channel C noise: " << (!(regValue & 0b0010'0000) ? "On " : "Off") << std::endl;
    ss << "  Port A I/O ctrl: " << (!(regValue & 0b0100'0000) ? "IN " : "OUT");
    ss << "  Port B I/O ctrl: " << (!(regValue & 0b0100'0000) ? "IN " : "OUT") << std::endl;

    return ss.str();
}

std::string SoundChip_AY8910::dumpAY8910ToneGeneratorState(uint8_t channel)
{
    const char* channelNames[] =
    {
        "Channel A",
        "Channel B",
        "Channel C"
    };

    std::stringstream ss;

    size_t fineIndex = AY_A_FINE + (2 * channel);
    size_t coarseIndex = AY_A_COARSE + (2 * channel);
    uint8_t fineValue = _registers[fineIndex];
    uint8_t coarseValue = _registers[coarseIndex] & 0x0000'FFFF;

    ss << "Tone " << channelNames[channel] << ":" << std::endl;
    ss << StringHelper::Format("  Coarse: %s (0x%02X, %d)", StringHelper::FormatBinary(coarseValue).c_str(), coarseValue, coarseValue) << std::endl;
    ss << StringHelper::Format("  Fine  : %s (0x%02X, %d)", StringHelper::FormatBinary(fineValue).c_str(), fineValue, fineValue) << std::endl;

    return ss.str();
}

std::string SoundChip_AY8910::dumpAY8910NoiseGeneratorState()
{
    std::stringstream ss;

    uint8_t period = _registers[AY_NOISE_PERIOD];

    ss << "Noise Generator: " << std::endl;
    ss << StringHelper::Format("  Period: %d (0x%04X)", period, period) << std::endl;

    return ss.str();
}

std::string SoundChip_AY8910::dumpAY8910EnvelopeGeneratorState()
{
    std::stringstream ss;

    uint16_t period = _envelopeGenerator.period();
    uint8_t shape = _envelopeGenerator.shape();

    ss << "Envelope Generator: " << std::endl;
    ss << StringHelper::Format("  Period: %d (0x%04X)", period, period) << std::endl;
    ss << StringHelper::Format("  Shape : %d (0x02X)", shape, shape);

    return ss.str();
}

std::string SoundChip_AY8910::dumpAY8910VolumeState(uint8_t channel)
{
    const char* channelNames[] =
    {
        "Channel A",
        "Channel B",
        "Channel C"
    };

    std::stringstream ss;
    size_t registerIndex = AY_A_VOLUME + channel;
    uint8_t registerValue = _registers[registerIndex];

    ss << "Volume " << channelNames[channel] << ":" << std::endl;
    ss << StringHelper::Format("  Amplitude  : 0x%04X", registerValue & 0b000'1111) << std::endl;
    ss << StringHelper::Format("  HW envelope: %s", registerValue & 0b001'0000 ? "on" : "off");

    return ss.str();
}

/// endregion <Debug methods>