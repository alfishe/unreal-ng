#pragma once

#include <cstdint>
#include <string>
#include <cmath>
#include "common/sound/filters/filter_dc.h"
#include "common/sound/filters/filter_interpolate.h"
#include "emulator/ports/portdecoder.h"

/// Information:
/// See:
///     https://en.wikipedia.org/wiki/General_Instrument_AY-3-8910
///     http://map.grauw.nl/resources/sound/generalinstrument_ay-3-8910.pdf
///     http://cpctech.cpc-live.com/docs/ay38912/psgspec.htm
///     https://www.cpcwiki.eu/index.php/Datasheet_AY-8913
///     http://www.armory.com/~rstevew/Public/SoundSynth/Novelty/AY3-8910/start.html
///     http://openmsx.org/doxygen/AY8910_8cc_source.html
///     https://github.com/mamedev/mame/blob/master/src/devices/sound/ay8910.cpp
///     http://spatula-city.org/~im14u2c/intv/jzintv-1.0-beta3/src/ay8910/ay8910.c
///     https://www.julien-nevo.com/arkostracker/index.php/ay-overview/
///     https://github.com/mamedev/mame/blob/master/src/devices/sound/ay8910.cpp

/// Base clock frequency is: 1.75MHz for Pentagon, 1.7734MHz for genuine ZX-Spectrum models
///


/// region <Types>

/// AY command registers enumeration
enum AYRegisterEnum : uint8_t
{
    AY_A_FINE = 0,              // R0
    AY_A_COARSE,                // R1
    AY_B_FINE,                  // R2
    AY_B_COARSE,                // R3
    AY_C_FINE,                  // R4
    AY_C_COARSE,                // R5
    AY_NOISE_PERIOD,            // R6
    AY_MIXER_CONTROL,           // R7
    AY_A_VOLUME,                // R8
    AY_B_VOLUME,                // R9
    AY_C_VOLUME,                // R10
    AY_ENVELOPE_PERIOD_FINE,    // R11
    AY_ENVELOPE_PERIOD_COARSE,  // R12
    AY_ENVELOPE_SHAPE,          // R13
    AY_PORTA,                   // R14
    AY_PORTB                    // R15
};

/// AY tone generators enumeration
enum AYChannelsEnum : uint8_t
{
    AY_CHANNEL_A = 0,
    AY_CHANNEL_B = 1,
    AY_CHANNEL_C = 2
};

/// endregion </Types>

class SoundChip_AY8910 : public PortDecoder, public PortDevice
{
    /// region <Constants>
protected:
    // Audio sampling rate is 44100Hz
    static const int AY_SAMPLING_RATE = 44100;

    // Oversampling factor (we'll be generating at that much higher sampling rate for better resolution)
    static const int AY_OVERSAMPLING_FACTOR = 64;   // For 44100 base sampling rate we'll have 44100 * 64 = 2.822MHz

    // Pentagon 128K/1024K has 1.75MHz AY frequency
    // ZX-Spectrum 128K, +2, +3 has 1.7734MHz AY frequency
    static constexpr int AY_BASE_FREQUENCY = 1.75 * 1'000'000;
    //static constexpr int AY_BASE_FREQUENCY = 1.7734 * 1'000'000;

    static constexpr int CPU_BASE_FREQUENCY = 3.5 * 1'000'000;
    static constexpr int CPU_CYCLES_PER_SAMPLE = CPU_BASE_FREQUENCY / AY_SAMPLING_RATE;


    // How many AY cycles in each audio sample (at selected sampling rate / frequency)
    static constexpr double CYCLES_PER_SAMPLE = AY_BASE_FREQUENCY / AY_SAMPLING_RATE;
public:
    static const char* AYRegisterNames[16];

protected:
    // Number of tone generators in AY8910
    static constexpr size_t TONE_CHANNELS = 3;

    // Chip-specific output amplitude (volume) logarithmic conversion table
    static constexpr double AY_DAC_TABLE[] =
    {
        0.0,              0.0,
        0.00999465934234, 0.00999465934234,
        0.01445029373620, 0.01445029373620,
        0.02105745021740, 0.02105745021740,
        0.03070115205620, 0.03070115205620,
        0.04554818036160, 0.04554818036160,
        0.06449988555730, 0.06449988555730,
        0.10736247806500, 0.10736247806500,
        0.12658884565500, 0.12658884565500,
        0.20498970016000, 0.20498970016000,
        0.29221026932200, 0.29221026932200,
        0.37283894102400, 0.37283894102400,
        0.49253070878200, 0.49253070878200,
        0.63532463569100, 0.63532463569100,
        0.80558480201400, 0.80558480201400,
        1.0, 1.0
    };

    static constexpr double YM_DAC_TABLE[] =
    {
        0.0, 0.0,
        0.00465400167849, 0.00772106507973,
        0.01095597772180, 0.01396200503550,
        0.01699855039290, 0.02001983672850,
        0.02436865796900, 0.02969405661100,
        0.03506523231860, 0.04039063096060,
        0.04853894865340, 0.05833524071110,
        0.06805523765930, 0.07777523460750,
        0.09251544975970, 0.11108567940800,
        0.12974746318800, 0.14848554207700,
        0.17666895552000, 0.21155107957600,
        0.24638742656600, 0.28110170138100,
        0.33373006790300, 0.40042725261300,
        0.46738384069600, 0.53443198291000,
        0.63517204547200, 0.75800717174000,
        0.87992675669500, 1.0
    };

    const double* _volumeDACTablePtr = (double*)&AY_DAC_TABLE;

    /// endregion </Constants>

    /// region <Nested classes>

    /// <b>Information:</b>
    /// Produce the basic square wave tone frequencies for each channel (A, B, C)
    ///
    /// The frequency of each square wave generated by the three Tone Generators
    /// (one each for Channels A, B, and C) is obtained in the PSG by first
    /// counting down the input clock by 16, then by further counting down the
    /// result by the programmed 12-bit Tone Period value. Each 12-bit value
    /// is obtained in the PSG by combining the contents of relative Coarse and
    /// Fine Tune registers. (R1 + R0 for Channel A, R3 + R2 for Channel B,
    /// R5 + R4 for Channel C)
    ///
    /// For 1.75MHz clock that means:
    /// Highest frequency = 109375Hz (1.75MHz / 16)
    /// Lowest frequency = 26.7Hz (1.75MHz / 65536)
    class ToneGenerator
    {
        /// region <Fields>
    protected:
        uint16_t _period;       // Tone Generator channel period (in AY clock cycles)
        uint16_t _counter;      // Current position in the period
        uint8_t _volume;        // Volume amplitude set via registers R10, R11, R12
        bool _envelopeEnabled;  // Is volume driven by envelope? (bit [5] of R10, R11 and R12)
        bool _toneEnabled;      // Is tone enabled? (bits 0, 1, 2 of R7)
        bool _noiseEnabled;     // Is noise enabled? (bits 3, 4, 5 of R7)

        double _panLeft;        // Panning coefficient for left channel (contribution to mixed stereo sample)
        double _panRight;       // Panning coefficient for right channel (contribution to mixed stereo sample)

        bool _out;          // Output bit
        /// endregion </Fields>

        /// region <Constructors / Destructors>
    public:
        ToneGenerator();
        /// endregion </Constructors / Destructors>

        /// region <Methods>
    public:
        void reset();
        void setPeriod(uint8_t fine, uint8_t coarse);
        void setVolume(uint8_t volume);
        void setEnvelopeEnabled(bool value);
        void setToneEnabled(bool value);
        void setNoiseEnabled(bool value);
        void setPanLeft(double value);
        void setPanRight(double value);

        uint8_t volume() const { return _volume; };
        bool envelopeEnabled() const { return _envelopeEnabled; }
        bool toneEnabled() const { return _toneEnabled; }
        bool noiseEnabled() const { return _noiseEnabled; };

        double panLeft() { return _panLeft; }
        double panRight() { return _panRight; }

        bool out() { return _out; };


        bool updateState();
        /// endregion </Methods>
    };

    /// <b>Information:</b>
    /// Produces a frequency modulated pseudo-random pulse-width square wave output
    ///
    /// The frequency of the noise source is obtained in the PSG by first counting
    /// down the input clock by 16, then by further counting down the result by
    /// the programmed 5-bit Noise Period (R6) value. This 5-bit value consists of
    /// the lower 5-bits (B4-B0) of register R6
    ///
    /// The Random Number Generator of the 8910 is a 17-bit shift register.
    /// The input to the shift register is bit0 XOR bit3, (bit0 is the output)
    class NoiseGenerator
    {
        /// region <Fields>
    protected:
        uint8_t _period;
        uint16_t _counter;  // Current position in the period
        bool _out;          // Output bit

        uint32_t _registerLSFR;
        /// endregion </Fields>

        /// region <Constructors / Destructors>
    public:
        NoiseGenerator();
        virtual ~NoiseGenerator() = default;
        /// endregion </Constructors / Destructors>

        /// region <Methods>
    public:
        void reset();
        void setPeriod(uint8_t period);
        void updateState();
        bool out() { return _out; };

    protected:
        inline bool shiftLSFR();
        /// endregion </Methods>
    };

    /// <b>Information:</b>
    /// Produces an envelope pattern which can be used to amplitude modulate the
    /// output of each Mixer (for channels A, B, C)
    ///
    /// The frequency of the envelope is obtained in the PSG by first counting down
    /// the input clock by 256, then by further counting down the result by the
    /// programmed 16-bit Envelope Period value. This 16-bit value is obtained in
    /// the PSG by combining the contents of the Envelope Coarse (R12) and
    /// Fine Tune (R11) registers
    ///
    /// For 1.75MHz clock that means:
    /// Highest frequency = 6836Hz (1.75MHz / 256)
    /// Lowest frequency = 0.1045 (1.75MHz / 16777216)
    class EnvelopeGenerator
    {
        /// region <Types>
        enum EnvelopeSegmentTypeEnum : uint8_t
        {
            Envelope_Decay = 0,     // Volume goes down
            Envelope_Attack = 1,    // Volume goes up
            Envelope_StayLow = 2,   // Volume stays low
            Envelope_StayHigh = 3   // Volume stays high
        };

        using EnvelopeHandler = void (*)(EnvelopeGenerator*);  // Define a type alias for the member function pointer type

        /// endregion </Types>

        /// region <Constants>
    protected:
        static const uint8_t ENVELOPE_SHAPE_COUNT = 16;
        static const uint8_t ENVELOPE_SEGMENTS = 2;
        static const uint8_t ENVELOPE_COUNTER_BITS = 5;
        static const uint8_t ENVELOPE_COUNTER_MAX = 1 << ENVELOPE_COUNTER_BITS;

        static EnvelopeHandler _handlers[ENVELOPE_SHAPE_COUNT][ENVELOPE_SEGMENTS];
        /// endregion </Constants>

        /// region <Fields>
    protected:
        uint8_t _shape;     // Selected envelope shape
        uint32_t _period;   // Envelope period - 16 bit value. 32 bit variable used to handle overflows
        uint32_t _counter;  // Current position in the period
        uint8_t  _segment;  // Envelope segment
        int8_t _out;        // Envelope generator output (5 bits amplitude value) (Note: it must be signed type to survive decrease below zero)
        /// endregion </Fields>

        /// region <Properties>
    public:
        int16_t period() { return (uint16_t)_period; }
        int8_t shape() { return _shape; }
        int8_t out() const { return _out; };
        /// endregion </Properties>

        /// region <Constructors / Destructors>
    public:
        EnvelopeGenerator();
        virtual ~EnvelopeGenerator() = default;
        /// endregion </Constructors / Destructors>

        /// region <Methods>
    public:
        void reset();
        void setPeriod(uint8_t fine, uint8_t coarse);
        void setShape(uint8_t shape);
        uint8_t updateState();
        /// endregion </Methods>

        /// region <Helper methods>
    protected:
        void resetSegment();
        /// endregion </Helper methods>

        /// region <Envelope handlers>
    protected:
        static void slideUp(EnvelopeGenerator* obj);
        static void slideDown(EnvelopeGenerator* obj);
        static void holdTop(EnvelopeGenerator* obj);
        static void holdBottom(EnvelopeGenerator* obj);
        /// endregion </Envelope handlers>
    };

    /// endregion </Nested classes>

    /// region <Fields>
protected:
    // AY8910 registers
    uint8_t _registers[16] = { 0 };

    // 3x Tone generators (A,B,C) + 1x Noise Generator + 1x Envelope Generator
    ToneGenerator _toneGenerators[3];
    NoiseGenerator _noiseGenerator;
    EnvelopeGenerator _envelopeGenerator;

    // Currently selected register (value of #BFFD)
    uint8_t _currentRegister;

    // Current AY tick
    size_t _tick;

    // Raw 3-channel samples
    double _left[3];
    double _right[3];

    // Mixed stereo samples
    double _mixedLeft;
    double _mixedRight;

    FilterInterpolate _leftFIR;
    FilterInterpolate _rightFIR;

    // Remove DC offset (work as analog capacitors per channel)
    FilterDC<double> _filterDCLeft;
    FilterDC<double> _filterDCRight;

    /// endregion </Fields>

    /// region <Interfacing fields>
protected:
    bool _chipAttachedToPortDecoder = false;
    PortDecoder* _portDecoder = nullptr;
    /// endregion </Interfacing fields>

    /// region <Constructors / Destructors>
public:
    SoundChip_AY8910(EmulatorContext* context);
    virtual ~SoundChip_AY8910() = default;
    /// endregion </Constructors / Destructors>

    /// region <Properties>
public:
    FilterInterpolate& firLeft() { return _leftFIR; }
    FilterInterpolate& firRight() { return _rightFIR; }

    double mixedLeft() { return _mixedLeft; }
    double mixedRight() { return _mixedRight; }
    int16_t outLeft() { return (int16_t)(_mixedLeft * (double)INT16_MAX); };
    int16_t outRight() { return (int16_t)(_mixedRight * (double)INT16_MAX); };

    double* left() { return _left; }
    double* right() { return _right; }

    /// endregion </Properties>

    /// region <Methods>
public:
    void reset();
    void updateState(bool bypassPrescaler = false);
    void updateMixer();

    void setMixer(uint8_t mixerValue);
    void setVolume(uint8_t volume, uint8_t channel);

    // Emulate physical interface with ports #BFFD, #FFFD
    void setRegister(uint8_t regAddr);
    uint8_t readCurrentRegister();
    void writeCurrentRegister(uint8_t value);

    // Logic-level interface
    uint8_t readRegister(uint8_t regAddr);
    void writeRegister(uint8_t regAddr, uint8_t value);

    /// endregion </Methods>

    /// region <Debug access methods>
public:
    // Access to internal state for debugging
    const uint8_t* getRegisters() const { return _registers; }
    const ToneGenerator* getToneGenerators() const { return _toneGenerators; }
    const NoiseGenerator& getNoiseGenerator() const { return _noiseGenerator; }
    const EnvelopeGenerator& getEnvelopeGenerator() const { return _envelopeGenerator; }
    uint8_t getCurrentRegister() const { return _currentRegister; }
    /// endregion </Debug access methods>

    /// region <PortDevice interface methods>
    uint8_t portDeviceInMethod(uint16_t port);
    void portDeviceOutMethod(uint16_t port, uint8_t value);
    /// endregion </PortDevice interface methods>

    /// region <Ports interaction>
public:
    bool attachToPorts(PortDecoder* decoder);
    void detachFromPorts();
    /// endregion </Ports interaction>

    /// region <Debug methods>
public:
    uint32_t getToneGeneratorDivisor(uint8_t fine, uint8_t coarse);
    double getToneGeneratorFrequency(size_t baseFrequency, uint8_t fine, uint8_t coarse);
    double getNoiseGeneratorFrequency(size_t baseFrequency, uint8_t divisor);

    std::string printFrequency(double frequency);
    std::string printToneDivisorsFromFrequency(double targetFrequency, double audioChipClockRate);

    std::string dumpAY8910State();
    std::string dumpAY8910MixerState();
    std::string dumpAY8910ToneGeneratorState(uint8_t channel);
    std::string dumpAY8910NoiseGeneratorState();
    std::string dumpAY8910EnvelopeGeneratorState();
    std::string dumpAY8910VolumeState(uint8_t channel);
    /// endregion <Debug methods>
};

//
// Code Under Test (CUT) wrappers to allow access protected and private properties and methods for unit testing / benchmark purposes
//
#ifdef _CODE_UNDER_TEST

// Expose all internal classes to public
class SoundChip_AY8910CUT : public SoundChip_AY8910
{
public:
    SoundChip_AY8910CUT(EmulatorContext* context) : SoundChip_AY8910(context) {};

    using SoundChip_AY8910::AY_BASE_FREQUENCY;
    using SoundChip_AY8910::CPU_BASE_FREQUENCY;

    using SoundChip_AY8910::ToneGenerator;
    using SoundChip_AY8910::NoiseGenerator;
    using SoundChip_AY8910::EnvelopeGenerator;
};

// Derive CUT class from publicized inner class and make all required fields public as well
class ToneGeneratorCUT : public SoundChip_AY8910CUT::ToneGenerator
{

};

// Derive CUT class from publicized inner class and make all required fields public as well
class NoiseGeneratorCUT: public SoundChip_AY8910CUT::NoiseGenerator
{

};

// Derive CUT class from publicized inner class and make all required fields public as well
class EnvelopeGeneratorCUT : public SoundChip_AY8910CUT::EnvelopeGenerator
{
public:

};

#endif // _CODE_UNDER_TEST