cmake_minimum_required(VERSION 3.12)
project(automation_python LANGUAGES CXX)

# Specify the C++ standard
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# Set paths
get_filename_component(ROOT_DIR ../../../ ABSOLUTE BASE_DIR ${CMAKE_CURRENT_SOURCE_DIR})
set (SOURCE_DIR src)
set (DATA_PATH ${ROOT_DIR}/data)

# Include CMake helper functions file
include(${ROOT_DIR}/cmake/func.cmake)


set(PYTHON_BUILD_DIR "${CMAKE_BINARY_DIR}/python_build")
#add_subdirectory(3rdparty/cmake-python-build ${PYTHON_BUILD_DIR})
#include(build-python.cmake)

# Turn on PYBIND option to find system Python
set(PYBIND11_FINDPYTHON ON)

# Add PyBind11 wrapper
add_subdirectory(3rdparty/pybind11)

if (APPLE)
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -mmacosx-version-min=10.13")
endif ()

# All C++ sources in /src and sub-folders will be compiled
file (GLOB_RECURSE CPP_FILES ${SOURCE_DIR}/*.cpp)
EXCLUDE_FILES_FROM_DIR_IN_LIST("${CPP_FILES}" "/build/" FALSE OUTVAR CPP_FILES)         # Exclude /build folder
EXCLUDE_FILES_FROM_DIR_IN_LIST("${CPP_FILES}" "/CMakeFiles/" FALSE OUTVAR CPP_FILES)    # Exclude /CMakeFile autogenerated files
set(SOURCES ${CPP_FILES} src/automation-main.cpp)
message("SOURCES:${SOURCES}")


if (CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)
    add_subdirectory(${ROOT_DIR}/core/src core)

    # Put binary and configuration files to /bin subfolder
    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)

    add_executable(${PROJECT_NAME} ${SOURCES})

    # Link python as static library
    target_link_libraries(${PROJECT_NAME}
        pybind11::embed
        Python3::Python
        #python_static
        #python3
        #python3.11.a

        unrealng::core
    )


    # Copy default config file to binary folder after successful compilation
    SET (CONFIG_FILE ${DATA_PATH}/configs/pentagon512k/unreal.ini)
    message("CONFIG_FILE: ${CONFIG_FILE}")
    message("Binary: ${CMAKE_BINARY_DIR}/${PROJECT_NAME}")
    add_custom_command(
            TARGET ${PROJECT_NAME} POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E
            copy ${CONFIG_FILE} "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/unreal.ini"
    )

    # Copy all ROM files to /rom sub-folder
    add_custom_command(
            TARGET ${PROJECT_NAME} POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E
            copy_directory ${DATA_PATH}/rom ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/rom
    )

    # Copy all test ROM files to /rom sub-folder
    add_custom_command(
            TARGET ${PROJECT_NAME} POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E
            copy_directory ${DATA_PATH}/testrom ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/rom
    )
else()
    # Produce static library;  Create unrealng::automation_python alias for the target
    add_library(${PROJECT_NAME} STATIC ${SOURCES})
    add_library(unrealng::${PROJECT_NAME} ALIAS ${PROJECT_NAME})

    # Add include directories for emulator headers
    target_include_directories(${PROJECT_NAME}
        PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/${SOURCE_DIR}
        ${ROOT_DIR}/core/src
    )

    # Link python as static library
    target_link_libraries(${PROJECT_NAME}
        pybind11::embed
        Python3::Python
        #python_static
        #python3
        #python3.11.a
    )
endif()




#set(PYTHON_LIB_DIR "${PYTHON_BUILD_DIR}/local/lib")
#target_link_directories(${PROJECT_NAME} PRIVATE ${PYTHON_LIB_DIR})

find_package(Python3 REQUIRED COMPONENTS Interpreter Development)

# Set the runtime search path for automation_python
set_target_properties(${PROJECT_NAME} PROPERTIES
        BUILD_WITH_INSTALL_RPATH TRUE
        INSTALL_RPATH "@loader_path/../lib"
        INSTALL_RPATH_USE_LINK_PATH TRUE
        )

if (APPLE)
  # Set dynamic linking path
  set(CMAKE_INSTALL_RPATH "/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.9/lib")
endif ()

add_dependencies(${PROJECT_NAME}
    pybind11::pybind11
)

# Add core include directories to access emulator headers
get_filename_component(CORE_SRC_DIR ${ROOT_DIR}/core/src ABSOLUTE BASE_DIR ${CMAKE_CURRENT_SOURCE_DIR})
target_include_directories(${PROJECT_NAME} PUBLIC
    $<BUILD_INTERFACE:${CORE_SRC_DIR}>
    $<INSTALL_INTERFACE:include>
)


# <Diagnostics>
get_target_property(APP_SOURCES ${PROJECT_NAME} SOURCES)
get_target_property(APP_INCLUDES ${PROJECT_NAME} INCLUDE_DIRECTORIES)

message(STATUS "<${PROJECT_NAME} diagnostics>")
message(STATUS "  PROJECT_NAME:             ${PROJECT_NAME}")
message(STATUS "  SOURCE_DIR:               ${SOURCE_DIR}")

message(STATUS "  APP_SOURCES:              ${APP_SOURCES}")
message(STATUS "  APP_INCLUDES:             ${APP_INCLUDES}")

message(STATUS "  DATA_PATH:                ${DATA_PATH}")

message(STATUS "</${PROJECT_NAME} diagnostics>")
# </Diagnostics>
